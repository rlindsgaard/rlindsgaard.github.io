---
title: Kaizen, Marginal Gains, and Software Engineering
layout: post
categories:
  - Software Engineering
---

# Kaizen, Marginal Gains, and Software Engineering

In his book _atomic habits_ and on his blog https://jamesclear.com/marginal-gains
James Clear uses the effect of marginal gains  
as a motivator for why consistency and focusing on small changes
can give great results. In essence, a one percent improvement every day
for a year ends up accumulating to 1.01^365 = 31.18 times better off.
A one percent decline accumulates to 0.99^365 = 0.03.

James Clear does not mention Kaizen specifically, but it is the
same philosophy applied.

In programming, as soon as we add lines of code, we add entropy,
we add complexity. Our mere act of writing code makes us 1% worse off
from the get-go. As Jeff Atwood puts it
https://blog.codinghorror.com/the-best-code-is-no-code-at-all/

_The best code is no code at all._

We have quite the nomenclature already for the "going south"-part.
"Entrophy", "Technical Debt", "Rot", "Legacy". So in general,
we are quite aware that there is a slippery slope and that we are
on it. These days, it is quite standard to have static checks
to ensure some quality, like e.g. linters. These checks does very
little to _improve_ the codebase however, they do make sure that
we are not going down with too much speed. At best, they serve
to help maintain status quo.

So what can we do about it? As an individual developer, what
measures may I take in order to improve whatever part of the codebase
I am currently working on? And how may I do it consistently in
order to counteract the rapid decline?



- Refactor, Refactor, Refactor

- Fix by design, not by code

- Apply Clean Code Principles

- Don't use deprecated mechanisms

- Avoid Unnecessary computation

- Plan JIT Refactoring

- Clean up the camp-ground-

# Adding Kaizen to the design practice


##
